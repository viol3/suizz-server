{
  "version": 3,
  "sources": ["../../../src/wallet/wallet.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Transaction } from '@mysten/sui/transactions';\nimport { fromBase64, toBase64 } from '@mysten/sui/utils';\nimport type {\n\tIdentifierString,\n\tStandardConnectFeature,\n\tStandardConnectMethod,\n\tStandardDisconnectFeature,\n\tStandardDisconnectMethod,\n\tStandardEventsFeature,\n\tStandardEventsOnMethod,\n\tSuiSignAndExecuteTransactionFeature,\n\tSuiSignAndExecuteTransactionMethod,\n\tSuiSignPersonalMessageFeature,\n\tSuiSignPersonalMessageMethod,\n\tSuiSignTransactionFeature,\n\tSuiSignTransactionMethod,\n\tWallet,\n} from '@mysten/wallet-standard';\nimport {\n\tReadonlyWalletAccount,\n\tStandardConnect,\n\tStandardDisconnect,\n\tStandardEvents,\n\tSuiSignAndExecuteTransaction,\n\tSuiSignPersonalMessage,\n\tSuiSignTransaction,\n} from '@mysten/wallet-standard';\nimport type { Emitter } from 'mitt';\nimport mitt from 'mitt';\n\nimport type { AuthProvider } from '../EnokiClient/type.js';\nimport type { EnokiWalletOptions, WalletEventsMap, EnokiSessionContext } from './types.js';\nimport type {\n\tEnokiGetMetadataFeature,\n\tEnokiGetMetadataMethod,\n\tEnokiGetSessionFeature,\n\tEnokiGetSessionMethod,\n} from './features.js';\nimport { EnokiGetMetadata, EnokiGetSession } from './features.js';\nimport type { Experimental_SuiClientTypes } from '@mysten/sui/experimental';\nimport { decodeJwt } from '@mysten/sui/zklogin';\nimport type { ExportedWebCryptoKeypair } from '@mysten/signers/webcrypto';\nimport { WebCryptoSigner } from '@mysten/signers/webcrypto';\nimport { get, set } from 'idb-keyval';\n\nimport { EnokiClient } from '../EnokiClient/index.js';\nimport type { EnokiNetwork } from '../EnokiClient/type.js';\nimport { EnokiKeypair } from '../EnokiKeypair.js';\n\nimport { EnokiWalletState } from './state.js';\nimport { allTasks } from 'nanostores';\n\nconst pkceFlowProviders: Partial<Record<AuthProvider, { tokenEndpoint: string }>> = {\n\tplaytron: {\n\t\ttokenEndpoint: 'https://oauth2.playtron.one/oauth2/token',\n\t},\n};\n\ntype PKCEContext = { codeChallenge: string; codeVerifier: string };\n\nexport class EnokiWallet implements Wallet {\n\t#events: Emitter<WalletEventsMap>;\n\t#accounts: ReadonlyWalletAccount[];\n\t#name: string;\n\t#icon: Wallet['icon'];\n\t#enokiClient: EnokiClient;\n\t#state: EnokiWalletState;\n\t#provider: AuthProvider;\n\t#clientId: string;\n\t#redirectUrl: string;\n\t#extraParams: Record<string, string> | (() => Record<string, string>) | undefined;\n\t#getCurrentNetwork: () => Experimental_SuiClientTypes.Network;\n\t#windowFeatures?: string | (() => string);\n\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\tget provider() {\n\t\treturn this.#provider;\n\t}\n\n\tget icon() {\n\t\treturn this.#icon;\n\t}\n\n\tget version() {\n\t\treturn '1.0.0' as const;\n\t}\n\n\tget chains() {\n\t\treturn [...this.#state.sessionContextByNetwork.keys()].map(\n\t\t\t(network) => `sui:${network}` as const,\n\t\t);\n\t}\n\n\tget accounts() {\n\t\treturn this.#accounts;\n\t}\n\n\tget features(): StandardConnectFeature &\n\t\tStandardDisconnectFeature &\n\t\tStandardEventsFeature &\n\t\tSuiSignTransactionFeature &\n\t\tSuiSignAndExecuteTransactionFeature &\n\t\tSuiSignPersonalMessageFeature &\n\t\tEnokiGetMetadataFeature &\n\t\tEnokiGetSessionFeature {\n\t\treturn {\n\t\t\t[StandardConnect]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tconnect: this.#connect,\n\t\t\t},\n\t\t\t[StandardDisconnect]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tdisconnect: this.#disconnect,\n\t\t\t},\n\t\t\t[StandardEvents]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\ton: this.#on,\n\t\t\t},\n\t\t\t[SuiSignTransaction]: {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignTransaction: this.#signTransaction,\n\t\t\t},\n\t\t\t[SuiSignAndExecuteTransaction]: {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignAndExecuteTransaction: this.#signAndExecuteTransaction,\n\t\t\t},\n\t\t\t[SuiSignPersonalMessage]: {\n\t\t\t\tversion: '1.1.0',\n\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t},\n\t\t\t[EnokiGetMetadata]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tgetMetadata: this.#getMetadata,\n\t\t\t},\n\t\t\t[EnokiGetSession]: {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tgetSession: this.#getSession,\n\t\t\t},\n\t\t};\n\t}\n\n\tconstructor({\n\t\tname,\n\t\ticon,\n\t\tprovider,\n\t\tclientId,\n\t\tredirectUrl,\n\t\textraParams,\n\t\twindowFeatures,\n\t\tgetCurrentNetwork,\n\t\tapiKey,\n\t\tapiUrl,\n\t\tclients,\n\t}: EnokiWalletOptions) {\n\t\tthis.#events = mitt();\n\t\tthis.#name = name;\n\t\tthis.#icon = icon;\n\t\tthis.#enokiClient = new EnokiClient({ apiKey, apiUrl });\n\t\tthis.#state = new EnokiWalletState({ apiKey, clientId, clients });\n\t\tthis.#provider = provider;\n\t\tthis.#clientId = clientId;\n\t\tthis.#redirectUrl = redirectUrl || window.location.href.split('#')[0];\n\t\tthis.#extraParams = extraParams;\n\t\tthis.#windowFeatures = windowFeatures;\n\t\tthis.#getCurrentNetwork = getCurrentNetwork;\n\t\tthis.#accounts = [];\n\n\t\tthis.#state.zkLoginState.subscribe(() => {\n\t\t\tthis.#accounts = this.#getAuthorizedAccounts();\n\t\t\tthis.#events.emit('change', { accounts: this.#accounts });\n\t\t});\n\t}\n\n\t#signTransaction: SuiSignTransactionMethod = async ({ transaction, chain, account, signal }) => {\n\t\tsignal?.throwIfAborted();\n\n\t\tconst { client, keypair } = await this.#getSignerContext(chain);\n\t\tconst parsedTransaction = Transaction.from(await transaction.toJSON());\n\t\tconst suiAddress = keypair.toSuiAddress();\n\n\t\tif (suiAddress !== account.address) {\n\t\t\tthrow new Error(\n\t\t\t\t`The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`,\n\t\t\t);\n\t\t}\n\n\t\tparsedTransaction.setSenderIfNotSet(suiAddress);\n\t\treturn keypair.signTransaction(await parsedTransaction.build({ client }));\n\t};\n\n\t#signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = async ({\n\t\ttransaction,\n\t\tchain,\n\t\taccount,\n\t\tsignal,\n\t}) => {\n\t\tsignal?.throwIfAborted();\n\n\t\tconst { client, keypair } = await this.#getSignerContext(chain);\n\t\tconst parsedTransaction = Transaction.from(await transaction.toJSON());\n\t\tconst bytes = await parsedTransaction.build({ client });\n\n\t\tconst suiAddress = keypair.toSuiAddress();\n\n\t\tif (suiAddress !== account.address) {\n\t\t\tthrow new Error(\n\t\t\t\t`The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`,\n\t\t\t);\n\t\t}\n\n\t\tparsedTransaction.setSenderIfNotSet(suiAddress);\n\n\t\tconst result = await keypair.signAndExecuteTransaction({\n\t\t\ttransaction: parsedTransaction,\n\t\t\tclient,\n\t\t});\n\n\t\treturn {\n\t\t\tbytes: toBase64(bytes),\n\t\t\tsignature: result.signatures[0],\n\t\t\tdigest: result.digest,\n\t\t\teffects: toBase64(result.effects.bcs!),\n\t\t};\n\t};\n\n\t#signPersonalMessage: SuiSignPersonalMessageMethod = async ({ message, account, chain }) => {\n\t\tconst { keypair } = await this.#getSignerContext(chain);\n\t\tconst suiAddress = keypair.toSuiAddress();\n\n\t\tif (suiAddress !== account.address) {\n\t\t\tthrow new Error(\n\t\t\t\t`The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`,\n\t\t\t);\n\t\t}\n\n\t\treturn keypair.signPersonalMessage(message);\n\t};\n\n\t#getMetadata: EnokiGetMetadataMethod = () => {\n\t\treturn {\n\t\t\tprovider: this.#provider,\n\t\t};\n\t};\n\n\t#getSession: EnokiGetSessionMethod = async (input) => {\n\t\tconst sessionContext = this.#state.getSessionContext(\n\t\t\tinput?.network ?? this.#getCurrentNetwork(),\n\t\t);\n\t\treturn await this.#state.getSession(sessionContext);\n\t};\n\n\t#on: StandardEventsOnMethod = (event, listener) => {\n\t\tthis.#events.on(event, listener);\n\t\treturn () => this.#events.off(event, listener);\n\t};\n\n\t#connect: StandardConnectMethod = async (input) => {\n\t\t// NOTE: This is a hackfix for the old version of dApp Kit where auto-connection logic\n\t\t// only fires on initial mount of the WalletProvider component. Since hydrating the\n\t\t// zkLogin state from IndexedDB is an asynchronous process, we need to make sure it\n\t\t// is populated before the connect logic runs.\n\t\tawait allTasks();\n\n\t\tif (input?.silent || this.#accounts.length > 0) {\n\t\t\treturn { accounts: this.#accounts };\n\t\t}\n\n\t\tconst currentNetwork = this.#getCurrentNetwork();\n\t\tawait this.#createSession({ network: currentNetwork });\n\n\t\treturn { accounts: this.#accounts };\n\t};\n\n\t#disconnect: StandardDisconnectMethod = async () => {\n\t\tawait this.#state.logout();\n\t\tthis.#accounts = [];\n\t\tthis.#events.emit('change', { accounts: this.#accounts });\n\t};\n\n\t#getAuthorizedAccounts() {\n\t\tconst zkLoginState = this.#state.zkLoginState.get();\n\t\tif (zkLoginState) {\n\t\t\treturn [\n\t\t\t\tnew ReadonlyWalletAccount({\n\t\t\t\t\taddress: zkLoginState.address,\n\t\t\t\t\tchains: this.chains,\n\t\t\t\t\ticon: this.icon,\n\t\t\t\t\tfeatures: [SuiSignPersonalMessage, SuiSignTransaction, SuiSignAndExecuteTransaction],\n\t\t\t\t\tpublicKey: fromBase64(zkLoginState.publicKey),\n\t\t\t\t}),\n\t\t\t];\n\t\t}\n\t\treturn [];\n\t}\n\n\tasync #getKeypair(sessionContext: EnokiSessionContext) {\n\t\tconst session = await this.#state.getSession(sessionContext);\n\t\tif (!session?.jwt || Date.now() > session.expiresAt) {\n\t\t\tawait this.#createSession({ network: sessionContext.client.network });\n\t\t}\n\n\t\tconst storedNativeSigner = await get<ExportedWebCryptoKeypair>(\n\t\t\t'ephemeralKeyPair',\n\t\t\tsessionContext.idbStore,\n\t\t);\n\n\t\tif (!storedNativeSigner) {\n\t\t\tthrow new Error('Native signer not found in store.');\n\t\t}\n\n\t\tconst updatedSession = await this.#state.getSession(sessionContext);\n\t\tif (!updatedSession?.jwt) {\n\t\t\tthrow new Error('Failed to retrieve an active session.');\n\t\t}\n\n\t\tconst ephemeralKeypair = WebCryptoSigner.import(storedNativeSigner);\n\t\tconst proof =\n\t\t\tupdatedSession.proof ??\n\t\t\t(await this.#enokiClient.createZkLoginZkp({\n\t\t\t\tnetwork: sessionContext.client.network as EnokiNetwork,\n\t\t\t\tjwt: updatedSession.jwt,\n\t\t\t\tmaxEpoch: updatedSession.maxEpoch,\n\t\t\t\trandomness: updatedSession.randomness,\n\t\t\t\tephemeralPublicKey: ephemeralKeypair.getPublicKey(),\n\t\t\t}));\n\n\t\tawait this.#state.setSession(sessionContext, { ...updatedSession, proof });\n\n\t\treturn new EnokiKeypair({\n\t\t\taddress: this.accounts[0].address,\n\t\t\tmaxEpoch: updatedSession.maxEpoch,\n\t\t\tephemeralKeypair,\n\t\t\tproof,\n\t\t});\n\t}\n\n\tasync #getSignerContext(chain?: IdentifierString) {\n\t\tconst sessionContext = chain ? this.#state.getSessionContext(chain.split(':')[1]) : null;\n\t\tif (!sessionContext) {\n\t\t\tthrow new Error(\n\t\t\t\t`A valid Sui chain identifier was not provided in the request. Please report this issue to the dApp developer. Examples of valid Sui chain identifiers are 'sui:testnet' and 'sui:mainnet'. Consider using the '@mysten/dapp-kit' package, which provides this value automatically.`,\n\t\t\t);\n\t\t}\n\n\t\tconst keypair = await this.#getKeypair(sessionContext);\n\t\treturn { client: sessionContext.client, keypair };\n\t}\n\n\tasync #createSession({ network }: { network: Experimental_SuiClientTypes.Network }) {\n\t\tconst popup = window.open(\n\t\t\tundefined,\n\t\t\t'_blank',\n\t\t\ttypeof this.#windowFeatures === 'function' ? this.#windowFeatures() : this.#windowFeatures,\n\t\t);\n\n\t\tif (!popup) {\n\t\t\tthrow new Error('Failed to open popup');\n\t\t}\n\n\t\tconst sessionContext = this.#state.getSessionContext(network);\n\t\tconst pkceContext = await this.#getPKCEFlowContext();\n\n\t\tpopup.location = await this.#createAuthorizationURL(sessionContext, pkceContext);\n\n\t\treturn await new Promise<void>((resolve, reject) => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\ttry {\n\t\t\t\t\tif (popup.closed) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\treject(new Error('Popup closed'));\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((!pkceContext && !popup.location.hash) || (pkceContext && !popup.location.search)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tclearInterval(interval);\n\n\t\t\t\tthis.#handleAuthCallback({\n\t\t\t\t\thash: popup.location.hash,\n\t\t\t\t\tsessionContext,\n\t\t\t\t\tsearch: popup.location.search,\n\t\t\t\t\tpkceContext,\n\t\t\t\t}).then(() => resolve(), reject);\n\n\t\t\t\ttry {\n\t\t\t\t\tpopup.close();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t}, 16);\n\t\t});\n\t}\n\n\tasync #getPKCEFlowContext(): Promise<PKCEContext | undefined> {\n\t\tif (!pkceFlowProviders[this.#provider]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst array = new Uint8Array(64);\n\t\tcrypto.getRandomValues(array);\n\t\tconst codeVerifier = toBase64(array).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n\t\tconst codeChallenge = toBase64(\n\t\t\tnew Uint8Array(await crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier))),\n\t\t)\n\t\t\t.replace(/=/g, '')\n\t\t\t.replace(/\\+/g, '-')\n\t\t\t.replace(/\\//g, '_');\n\n\t\treturn { codeVerifier, codeChallenge };\n\t}\n\n\tasync #createAuthorizationURL(sessionContext: EnokiSessionContext, pkceContext?: PKCEContext) {\n\t\tconst ephemeralKeyPair = await WebCryptoSigner.generate();\n\t\tconst { nonce, randomness, maxEpoch, estimatedExpiration } =\n\t\t\tawait this.#enokiClient.createZkLoginNonce({\n\t\t\t\tnetwork: sessionContext.client.network as EnokiNetwork,\n\t\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t\t});\n\n\t\tconst extraParams =\n\t\t\ttypeof this.#extraParams === 'function' ? this.#extraParams() : this.#extraParams;\n\n\t\tconst params = new URLSearchParams({\n\t\t\t...extraParams,\n\t\t\tnonce,\n\t\t\tclient_id: this.#clientId,\n\t\t\tredirect_uri: this.#redirectUrl,\n\t\t\tresponse_type: 'id_token',\n\t\t\tscope: ['openid', ...(extraParams?.scope ? extraParams.scope.split(' ') : [])]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(' '),\n\t\t\t...(pkceContext\n\t\t\t\t? {\n\t\t\t\t\t\tresponse_type: 'code',\n\t\t\t\t\t\tcode_challenge_method: 'S256',\n\t\t\t\t\t\tcode_challenge: pkceContext.codeChallenge,\n\t\t\t\t\t}\n\t\t\t\t: undefined),\n\t\t});\n\n\t\tlet oauthUrl: string;\n\t\tswitch (this.#provider) {\n\t\t\tcase 'google':\n\t\t\t\toauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;\n\t\t\t\tbreak;\n\t\t\tcase 'facebook':\n\t\t\t\toauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;\n\t\t\t\tbreak;\n\t\t\tcase 'twitch':\n\t\t\t\tparams.set('force_verify', 'true');\n\t\t\t\toauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;\n\t\t\t\tbreak;\n\t\t\tcase 'onefc':\n\t\t\t\toauthUrl = `https://login.onepassport.onefc.com/de3ee5c1-5644-4113-922d-e8336569a462/b2c_1a_prod_signupsignin_onesuizklogin/oauth2/v2.0/authorize?${params}`;\n\t\t\t\tbreak;\n\t\t\tcase 'playtron':\n\t\t\t\toauthUrl = `https://oauth2.playtron.one/oauth2/auth?${params}`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid provider: ${this.#provider}`);\n\t\t}\n\n\t\tawait set('ephemeralKeyPair', ephemeralKeyPair.export(), sessionContext.idbStore);\n\t\tawait this.#state.setSession(sessionContext, {\n\t\t\texpiresAt: estimatedExpiration,\n\t\t\tmaxEpoch,\n\t\t\trandomness,\n\t\t});\n\n\t\treturn oauthUrl;\n\t}\n\n\tasync #handleAuthCallback({\n\t\thash,\n\t\tsessionContext,\n\t\tpkceContext,\n\t\tsearch,\n\t}: {\n\t\thash: string;\n\t\tsessionContext: EnokiSessionContext;\n\t\tpkceContext?: PKCEContext;\n\t\tsearch: string;\n\t}) {\n\t\tconst params = new URLSearchParams(hash.startsWith('#') ? hash.slice(1) : hash);\n\t\tconst zkp = await this.#state.getSession(sessionContext);\n\n\t\tif (!zkp?.maxEpoch || !zkp.randomness) {\n\t\t\tthrow new Error(\n\t\t\t\t'Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this.',\n\t\t\t);\n\t\t}\n\n\t\tconst jwt = pkceContext\n\t\t\t? await this.#pkceTokenExchange(search, pkceContext)\n\t\t\t: params.get('id_token');\n\n\t\tif (!jwt) {\n\t\t\tthrow new Error('Missing ID Token');\n\t\t}\n\n\t\tdecodeJwt(jwt);\n\n\t\tconst { address, publicKey } = await this.#enokiClient.getZkLogin({ jwt });\n\n\t\tthis.#state.zkLoginState.set({ address, publicKey });\n\t\tawait this.#state.setSession(sessionContext, { ...zkp, jwt });\n\n\t\treturn params.get('state');\n\t}\n\n\tasync #pkceTokenExchange(search: string, pkceContext: PKCEContext) {\n\t\tconst params = new URLSearchParams(search);\n\t\tconst code = params.get('code');\n\n\t\tif (!code) {\n\t\t\tthrow new Error('Missing code');\n\t\t}\n\n\t\tconst tokenEndpoint = pkceFlowProviders[this.#provider]?.tokenEndpoint;\n\n\t\tif (!tokenEndpoint) {\n\t\t\tthrow new Error(`PKCE flow not supported for provider: ${this.#provider}`);\n\t\t}\n\n\t\tconst response = await fetch(tokenEndpoint, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tgrant_type: 'authorization_code',\n\t\t\t\tclient_id: this.#clientId,\n\t\t\t\tredirect_uri: this.#redirectUrl,\n\t\t\t\tcode,\n\t\t\t\tcode_verifier: pkceContext.codeVerifier,\n\t\t\t}),\n\t\t});\n\n\t\treturn (await response.json()).id_token;\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,0BAA4B;AAC5B,mBAAqC;AAiBrC,6BAQO;AAEP,kBAAiB;AAUjB,sBAAkD;AAElD,qBAA0B;AAE1B,uBAAgC;AAChC,wBAAyB;AAEzB,yBAA4B;AAE5B,0BAA6B;AAE7B,mBAAiC;AACjC,wBAAyB;AArDzB;AAuDA,MAAM,oBAA8E;AAAA,EACnF,UAAU;AAAA,IACT,eAAe;AAAA,EAChB;AACD;AAIO,MAAM,YAA8B;AAAA,EAoF1C,YAAY;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,GAAuB;AAhGjB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwGA,yCAA6C,OAAO,EAAE,aAAa,OAAO,SAAS,OAAO,MAAM;AAC/F,cAAQ,eAAe;AAEvB,YAAM,EAAE,QAAQ,QAAQ,IAAI,MAAM,sBAAK,6CAAL,WAAuB;AACzD,YAAM,oBAAoB,gCAAY,KAAK,MAAM,YAAY,OAAO,CAAC;AACrE,YAAM,aAAa,QAAQ,aAAa;AAExC,UAAI,eAAe,QAAQ,SAAS;AACnC,cAAM,IAAI;AAAA,UACT,yBAAyB,QAAQ,OAAO,yDAAyD,UAAU;AAAA,QAC5G;AAAA,MACD;AAEA,wBAAkB,kBAAkB,UAAU;AAC9C,aAAO,QAAQ,gBAAgB,MAAM,kBAAkB,MAAM,EAAE,OAAO,CAAC,CAAC;AAAA,IACzE;AAEA,mDAAiE,OAAO;AAAA,MACvE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD,MAAM;AACL,cAAQ,eAAe;AAEvB,YAAM,EAAE,QAAQ,QAAQ,IAAI,MAAM,sBAAK,6CAAL,WAAuB;AACzD,YAAM,oBAAoB,gCAAY,KAAK,MAAM,YAAY,OAAO,CAAC;AACrE,YAAM,QAAQ,MAAM,kBAAkB,MAAM,EAAE,OAAO,CAAC;AAEtD,YAAM,aAAa,QAAQ,aAAa;AAExC,UAAI,eAAe,QAAQ,SAAS;AACnC,cAAM,IAAI;AAAA,UACT,yBAAyB,QAAQ,OAAO,yDAAyD,UAAU;AAAA,QAC5G;AAAA,MACD;AAEA,wBAAkB,kBAAkB,UAAU;AAE9C,YAAM,SAAS,MAAM,QAAQ,0BAA0B;AAAA,QACtD,aAAa;AAAA,QACb;AAAA,MACD,CAAC;AAED,aAAO;AAAA,QACN,WAAO,uBAAS,KAAK;AAAA,QACrB,WAAW,OAAO,WAAW,CAAC;AAAA,QAC9B,QAAQ,OAAO;AAAA,QACf,aAAS,uBAAS,OAAO,QAAQ,GAAI;AAAA,MACtC;AAAA,IACD;AAEA,6CAAqD,OAAO,EAAE,SAAS,SAAS,MAAM,MAAM;AAC3F,YAAM,EAAE,QAAQ,IAAI,MAAM,sBAAK,6CAAL,WAAuB;AACjD,YAAM,aAAa,QAAQ,aAAa;AAExC,UAAI,eAAe,QAAQ,SAAS;AACnC,cAAM,IAAI;AAAA,UACT,yBAAyB,QAAQ,OAAO,yDAAyD,UAAU;AAAA,QAC5G;AAAA,MACD;AAEA,aAAO,QAAQ,oBAAoB,OAAO;AAAA,IAC3C;AAEA,qCAAuC,MAAM;AAC5C,aAAO;AAAA,QACN,UAAU,mBAAK;AAAA,MAChB;AAAA,IACD;AAEA,oCAAqC,OAAO,UAAU;AACrD,YAAM,iBAAiB,mBAAK,QAAO;AAAA,QAClC,OAAO,WAAW,mBAAK,oBAAL;AAAA,MACnB;AACA,aAAO,MAAM,mBAAK,QAAO,WAAW,cAAc;AAAA,IACnD;AAEA,4BAA8B,CAAC,OAAO,aAAa;AAClD,yBAAK,SAAQ,GAAG,OAAO,QAAQ;AAC/B,aAAO,MAAM,mBAAK,SAAQ,IAAI,OAAO,QAAQ;AAAA,IAC9C;AAEA,iCAAkC,OAAO,UAAU;AAKlD,gBAAM,4BAAS;AAEf,UAAI,OAAO,UAAU,mBAAK,WAAU,SAAS,GAAG;AAC/C,eAAO,EAAE,UAAU,mBAAK,WAAU;AAAA,MACnC;AAEA,YAAM,iBAAiB,mBAAK,oBAAL;AACvB,YAAM,sBAAK,0CAAL,WAAoB,EAAE,SAAS,eAAe;AAEpD,aAAO,EAAE,UAAU,mBAAK,WAAU;AAAA,IACnC;AAEA,oCAAwC,YAAY;AACnD,YAAM,mBAAK,QAAO,OAAO;AACzB,yBAAK,WAAY,CAAC;AAClB,yBAAK,SAAQ,KAAK,UAAU,EAAE,UAAU,mBAAK,WAAU,CAAC;AAAA,IACzD;AA3HC,uBAAK,aAAU,YAAAA,SAAK;AACpB,uBAAK,OAAQ;AACb,uBAAK,OAAQ;AACb,uBAAK,cAAe,IAAI,+BAAY,EAAE,QAAQ,OAAO,CAAC;AACtD,uBAAK,QAAS,IAAI,8BAAiB,EAAE,QAAQ,UAAU,QAAQ,CAAC;AAChE,uBAAK,WAAY;AACjB,uBAAK,WAAY;AACjB,uBAAK,cAAe,eAAe,OAAO,SAAS,KAAK,MAAM,GAAG,EAAE,CAAC;AACpE,uBAAK,cAAe;AACpB,uBAAK,iBAAkB;AACvB,uBAAK,oBAAqB;AAC1B,uBAAK,WAAY,CAAC;AAElB,uBAAK,QAAO,aAAa,UAAU,MAAM;AACxC,yBAAK,WAAY,sBAAK,kDAAL;AACjB,yBAAK,SAAQ,KAAK,UAAU,EAAE,UAAU,mBAAK,WAAU,CAAC;AAAA,IACzD,CAAC;AAAA,EACF;AAAA,EApGA,IAAI,OAAO;AACV,WAAO,mBAAK;AAAA,EACb;AAAA,EAEA,IAAI,WAAW;AACd,WAAO,mBAAK;AAAA,EACb;AAAA,EAEA,IAAI,OAAO;AACV,WAAO,mBAAK;AAAA,EACb;AAAA,EAEA,IAAI,UAAU;AACb,WAAO;AAAA,EACR;AAAA,EAEA,IAAI,SAAS;AACZ,WAAO,CAAC,GAAG,mBAAK,QAAO,wBAAwB,KAAK,CAAC,EAAE;AAAA,MACtD,CAAC,YAAY,OAAO,OAAO;AAAA,IAC5B;AAAA,EACD;AAAA,EAEA,IAAI,WAAW;AACd,WAAO,mBAAK;AAAA,EACb;AAAA,EAEA,IAAI,WAOoB;AACvB,WAAO;AAAA,MACN,CAAC,sCAAe,GAAG;AAAA,QAClB,SAAS;AAAA,QACT,SAAS,mBAAK;AAAA,MACf;AAAA,MACA,CAAC,yCAAkB,GAAG;AAAA,QACrB,SAAS;AAAA,QACT,YAAY,mBAAK;AAAA,MAClB;AAAA,MACA,CAAC,qCAAc,GAAG;AAAA,QACjB,SAAS;AAAA,QACT,IAAI,mBAAK;AAAA,MACV;AAAA,MACA,CAAC,yCAAkB,GAAG;AAAA,QACrB,SAAS;AAAA,QACT,iBAAiB,mBAAK;AAAA,MACvB;AAAA,MACA,CAAC,mDAA4B,GAAG;AAAA,QAC/B,SAAS;AAAA,QACT,2BAA2B,mBAAK;AAAA,MACjC;AAAA,MACA,CAAC,6CAAsB,GAAG;AAAA,QACzB,SAAS;AAAA,QACT,qBAAqB,mBAAK;AAAA,MAC3B;AAAA,MACA,CAAC,gCAAgB,GAAG;AAAA,QACnB,SAAS;AAAA,QACT,aAAa,mBAAK;AAAA,MACnB;AAAA,MACA,CAAC,+BAAe,GAAG;AAAA,QAClB,SAAS;AAAA,QACT,YAAY,mBAAK;AAAA,MAClB;AAAA,IACD;AAAA,EACD;AAiZD;AAleC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwGA;AAiBA;AAmCA;AAaA;AAMA;AAOA;AAKA;AAiBA;AAxNM;AA8NN,2BAAsB,WAAG;AACxB,QAAM,eAAe,mBAAK,QAAO,aAAa,IAAI;AAClD,MAAI,cAAc;AACjB,WAAO;AAAA,MACN,IAAI,6CAAsB;AAAA,QACzB,SAAS,aAAa;AAAA,QACtB,QAAQ,KAAK;AAAA,QACb,MAAM,KAAK;AAAA,QACX,UAAU,CAAC,+CAAwB,2CAAoB,mDAA4B;AAAA,QACnF,eAAW,yBAAW,aAAa,SAAS;AAAA,MAC7C,CAAC;AAAA,IACF;AAAA,EACD;AACA,SAAO,CAAC;AACT;AAEM,gBAAW,eAAC,gBAAqC;AACtD,QAAM,UAAU,MAAM,mBAAK,QAAO,WAAW,cAAc;AAC3D,MAAI,CAAC,SAAS,OAAO,KAAK,IAAI,IAAI,QAAQ,WAAW;AACpD,UAAM,sBAAK,0CAAL,WAAoB,EAAE,SAAS,eAAe,OAAO,QAAQ;AAAA,EACpE;AAEA,QAAM,qBAAqB,UAAM;AAAA,IAChC;AAAA,IACA,eAAe;AAAA,EAChB;AAEA,MAAI,CAAC,oBAAoB;AACxB,UAAM,IAAI,MAAM,mCAAmC;AAAA,EACpD;AAEA,QAAM,iBAAiB,MAAM,mBAAK,QAAO,WAAW,cAAc;AAClE,MAAI,CAAC,gBAAgB,KAAK;AACzB,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACxD;AAEA,QAAM,mBAAmB,iCAAgB,OAAO,kBAAkB;AAClE,QAAM,QACL,eAAe,SACd,MAAM,mBAAK,cAAa,iBAAiB;AAAA,IACzC,SAAS,eAAe,OAAO;AAAA,IAC/B,KAAK,eAAe;AAAA,IACpB,UAAU,eAAe;AAAA,IACzB,YAAY,eAAe;AAAA,IAC3B,oBAAoB,iBAAiB,aAAa;AAAA,EACnD,CAAC;AAEF,QAAM,mBAAK,QAAO,WAAW,gBAAgB,EAAE,GAAG,gBAAgB,MAAM,CAAC;AAEzE,SAAO,IAAI,iCAAa;AAAA,IACvB,SAAS,KAAK,SAAS,CAAC,EAAE;AAAA,IAC1B,UAAU,eAAe;AAAA,IACzB;AAAA,IACA;AAAA,EACD,CAAC;AACF;AAEM,sBAAiB,eAAC,OAA0B;AACjD,QAAM,iBAAiB,QAAQ,mBAAK,QAAO,kBAAkB,MAAM,MAAM,GAAG,EAAE,CAAC,CAAC,IAAI;AACpF,MAAI,CAAC,gBAAgB;AACpB,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AAEA,QAAM,UAAU,MAAM,sBAAK,uCAAL,WAAiB;AACvC,SAAO,EAAE,QAAQ,eAAe,QAAQ,QAAQ;AACjD;AAEM,mBAAc,eAAC,EAAE,QAAQ,GAAqD;AACnF,QAAM,QAAQ,OAAO;AAAA,IACpB;AAAA,IACA;AAAA,IACA,OAAO,mBAAK,qBAAoB,aAAa,mBAAK,iBAAL,aAAyB,mBAAK;AAAA,EAC5E;AAEA,MAAI,CAAC,OAAO;AACX,UAAM,IAAI,MAAM,sBAAsB;AAAA,EACvC;AAEA,QAAM,iBAAiB,mBAAK,QAAO,kBAAkB,OAAO;AAC5D,QAAM,cAAc,MAAM,sBAAK,+CAAL;AAE1B,QAAM,WAAW,MAAM,sBAAK,mDAAL,WAA6B,gBAAgB;AAEpE,SAAO,MAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AACnD,UAAM,WAAW,YAAY,MAAM;AAClC,UAAI;AACH,YAAI,MAAM,QAAQ;AACjB,wBAAc,QAAQ;AACtB,iBAAO,IAAI,MAAM,cAAc,CAAC;AAAA,QACjC;AAEA,YAAK,CAAC,eAAe,CAAC,MAAM,SAAS,QAAU,eAAe,CAAC,MAAM,SAAS,QAAS;AACtF;AAAA,QACD;AAAA,MACD,SAAS,GAAG;AACX;AAAA,MACD;AACA,oBAAc,QAAQ;AAEtB,4BAAK,+CAAL,WAAyB;AAAA,QACxB,MAAM,MAAM,SAAS;AAAA,QACrB;AAAA,QACA,QAAQ,MAAM,SAAS;AAAA,QACvB;AAAA,MACD,GAAG,KAAK,MAAM,QAAQ,GAAG,MAAM;AAE/B,UAAI;AACH,cAAM,MAAM;AAAA,MACb,SAAS,GAAG;AACX,gBAAQ,MAAM,CAAC;AAAA,MAChB;AAAA,IACD,GAAG,EAAE;AAAA,EACN,CAAC;AACF;AAEM,wBAAmB,iBAAqC;AAC7D,MAAI,CAAC,kBAAkB,mBAAK,UAAS,GAAG;AACvC;AAAA,EACD;AAEA,QAAM,QAAQ,IAAI,WAAW,EAAE;AAC/B,SAAO,gBAAgB,KAAK;AAC5B,QAAM,mBAAe,uBAAS,KAAK,EAAE,QAAQ,MAAM,EAAE,EAAE,QAAQ,OAAO,GAAG,EAAE,QAAQ,OAAO,GAAG;AAC7F,QAAM,oBAAgB;AAAA,IACrB,IAAI,WAAW,MAAM,OAAO,OAAO,OAAO,WAAW,IAAI,YAAY,EAAE,OAAO,YAAY,CAAC,CAAC;AAAA,EAC7F,EACE,QAAQ,MAAM,EAAE,EAChB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG;AAEpB,SAAO,EAAE,cAAc,cAAc;AACtC;AAEM,4BAAuB,eAAC,gBAAqC,aAA2B;AAC7F,QAAM,mBAAmB,MAAM,iCAAgB,SAAS;AACxD,QAAM,EAAE,OAAO,YAAY,UAAU,oBAAoB,IACxD,MAAM,mBAAK,cAAa,mBAAmB;AAAA,IAC1C,SAAS,eAAe,OAAO;AAAA,IAC/B,oBAAoB,iBAAiB,aAAa;AAAA,EACnD,CAAC;AAEF,QAAM,cACL,OAAO,mBAAK,kBAAiB,aAAa,mBAAK,cAAL,aAAsB,mBAAK;AAEtE,QAAM,SAAS,IAAI,gBAAgB;AAAA,IAClC,GAAG;AAAA,IACH;AAAA,IACA,WAAW,mBAAK;AAAA,IAChB,cAAc,mBAAK;AAAA,IACnB,eAAe;AAAA,IACf,OAAO,CAAC,UAAU,GAAI,aAAa,QAAQ,YAAY,MAAM,MAAM,GAAG,IAAI,CAAC,CAAE,EAC3E,OAAO,OAAO,EACd,KAAK,GAAG;AAAA,IACV,GAAI,cACD;AAAA,MACA,eAAe;AAAA,MACf,uBAAuB;AAAA,MACvB,gBAAgB,YAAY;AAAA,IAC7B,IACC;AAAA,EACJ,CAAC;AAED,MAAI;AACJ,UAAQ,mBAAK,YAAW;AAAA,IACvB,KAAK;AACJ,iBAAW,gDAAgD,MAAM;AACjE;AAAA,IACD,KAAK;AACJ,iBAAW,+CAA+C,MAAM;AAChE;AAAA,IACD,KAAK;AACJ,aAAO,IAAI,gBAAgB,MAAM;AACjC,iBAAW,yCAAyC,MAAM;AAC1D;AAAA,IACD,KAAK;AACJ,iBAAW,yIAAyI,MAAM;AAC1J;AAAA,IACD,KAAK;AACJ,iBAAW,2CAA2C,MAAM;AAC5D;AAAA,IACD;AACC,YAAM,IAAI,MAAM,qBAAqB,mBAAK,UAAS,EAAE;AAAA,EACvD;AAEA,YAAM,uBAAI,oBAAoB,iBAAiB,OAAO,GAAG,eAAe,QAAQ;AAChF,QAAM,mBAAK,QAAO,WAAW,gBAAgB;AAAA,IAC5C,WAAW;AAAA,IACX;AAAA,IACA;AAAA,EACD,CAAC;AAED,SAAO;AACR;AAEM,wBAAmB,eAAC;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,GAKG;AACF,QAAM,SAAS,IAAI,gBAAgB,KAAK,WAAW,GAAG,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI;AAC9E,QAAM,MAAM,MAAM,mBAAK,QAAO,WAAW,cAAc;AAEvD,MAAI,CAAC,KAAK,YAAY,CAAC,IAAI,YAAY;AACtC,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AAEA,QAAM,MAAM,cACT,MAAM,sBAAK,8CAAL,WAAwB,QAAQ,eACtC,OAAO,IAAI,UAAU;AAExB,MAAI,CAAC,KAAK;AACT,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACnC;AAEA,gCAAU,GAAG;AAEb,QAAM,EAAE,SAAS,UAAU,IAAI,MAAM,mBAAK,cAAa,WAAW,EAAE,IAAI,CAAC;AAEzE,qBAAK,QAAO,aAAa,IAAI,EAAE,SAAS,UAAU,CAAC;AACnD,QAAM,mBAAK,QAAO,WAAW,gBAAgB,EAAE,GAAG,KAAK,IAAI,CAAC;AAE5D,SAAO,OAAO,IAAI,OAAO;AAC1B;AAEM,uBAAkB,eAAC,QAAgB,aAA0B;AAClE,QAAM,SAAS,IAAI,gBAAgB,MAAM;AACzC,QAAM,OAAO,OAAO,IAAI,MAAM;AAE9B,MAAI,CAAC,MAAM;AACV,UAAM,IAAI,MAAM,cAAc;AAAA,EAC/B;AAEA,QAAM,gBAAgB,kBAAkB,mBAAK,UAAS,GAAG;AAEzD,MAAI,CAAC,eAAe;AACnB,UAAM,IAAI,MAAM,yCAAyC,mBAAK,UAAS,EAAE;AAAA,EAC1E;AAEA,QAAM,WAAW,MAAM,MAAM,eAAe;AAAA,IAC3C,QAAQ;AAAA,IACR,MAAM,IAAI,gBAAgB;AAAA,MACzB,YAAY;AAAA,MACZ,WAAW,mBAAK;AAAA,MAChB,cAAc,mBAAK;AAAA,MACnB;AAAA,MACA,eAAe,YAAY;AAAA,IAC5B,CAAC;AAAA,EACF,CAAC;AAED,UAAQ,MAAM,SAAS,KAAK,GAAG;AAChC;",
  "names": ["mitt"]
}
