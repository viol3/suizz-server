{
  "version": 3,
  "sources": ["../../src/EnokiFlow.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ExportedWebCryptoKeypair } from '@mysten/signers/webcrypto';\nimport { WebCryptoSigner } from '@mysten/signers/webcrypto';\nimport { decodeSuiPrivateKey } from '@mysten/sui/cryptography';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport { fromBase64, toBase64 } from '@mysten/sui/utils';\nimport { decodeJwt } from '@mysten/sui/zklogin';\nimport type { ZkLoginSignatureInputs } from '@mysten/sui/zklogin';\nimport type { UseStore } from 'idb-keyval';\nimport { clear, createStore, get, set } from 'idb-keyval';\nimport type { WritableAtom } from 'nanostores';\nimport { atom, onMount, onSet } from 'nanostores';\n\nimport type { Encryption } from './encryption.js';\nimport { createDefaultEncryption } from './encryption.js';\nimport type { EnokiClientConfig } from './EnokiClient/index.js';\nimport { EnokiClient } from './EnokiClient/index.js';\nimport type { AuthProvider, EnokiNetwork } from './EnokiClient/type.js';\nimport { EnokiKeypair } from './EnokiKeypair.js';\nimport type { SyncStore } from './stores.js';\nimport { createSessionStorage } from './stores.js';\n\n/**\n * @deprecated Use `RegisterEnokiWalletsOptions` instead\n */\nexport type EnokiFlowConfig = EnokiClientConfig &\n\t(\n\t\t| {\n\t\t\t\texperimental_nativeCryptoSigner?: unknown;\n\t\t\t\t/**\n\t\t\t\t * The storage interface to persist Enoki data locally.\n\t\t\t\t * If not provided, it will use a sessionStorage-backed store.\n\t\t\t\t */\n\t\t\t\tstore?: SyncStore;\n\t\t\t\t/**\n\t\t\t\t * The encryption interface that will be used to encrypt data before storing it locally.\n\t\t\t\t * If not provided, it will use a default encryption interface.\n\t\t\t\t */\n\t\t\t\tencryption?: Encryption;\n\t\t  }\n\t\t| {\n\t\t\t\tstore?: never;\n\t\t\t\tencryption?: never;\n\t\t\t\t/**\n\t\t\t\t * Enables the new native crypto signer for the EnokiFlow, which is more secure.\n\t\t\t\t */\n\t\t\t\texperimental_nativeCryptoSigner: true;\n\t\t  }\n\t);\n\n// State that is not bound to a session, and is encrypted.\nexport interface ZkLoginState {\n\tprovider?: AuthProvider;\n\taddress?: string;\n\tsalt?: string;\n\tpublicKey?: string;\n}\n\n// State that session-bound, and is encrypted in storage.\nexport interface ZkLoginSession {\n\tephemeralKeyPair: string;\n\tmaxEpoch: number;\n\trandomness: string;\n\texpiresAt: number;\n\n\tjwt?: string;\n\tproof?: ZkLoginSignatureInputs;\n}\n\nconst createStorageKeys = (apiKey: string) => ({\n\tSTATE: `@enoki/flow/state/${apiKey}`,\n\tSESSION: `@enoki/flow/session/${apiKey}`,\n});\n\n/**\n * @deprecated Use `registerEnokiWallets` instead\n */\nexport class EnokiFlow {\n\t#storageKeys: { STATE: string; SESSION: string };\n\t#enokiClient: EnokiClient;\n\t#encryption: Encryption;\n\t#encryptionKey: string;\n\t#store: SyncStore;\n\t#useNativeCryptoSigner: boolean;\n\t#idbStore?: UseStore;\n\n\t$zkLoginSession: WritableAtom<{ initialized: boolean; value: ZkLoginSession | null }>;\n\t$zkLoginState: WritableAtom<ZkLoginState>;\n\n\tconstructor(config: EnokiFlowConfig) {\n\t\tthis.#enokiClient = new EnokiClient({\n\t\t\tapiKey: config.apiKey,\n\t\t\tapiUrl: config.apiUrl,\n\t\t});\n\t\tthis.#encryptionKey = config.apiKey;\n\n\t\tif (config.experimental_nativeCryptoSigner) {\n\t\t\tthis.#useNativeCryptoSigner = true;\n\t\t\tthis.#idbStore = createStore(config.apiKey, 'enoki');\n\t\t} else {\n\t\t\tthis.#useNativeCryptoSigner = false;\n\t\t}\n\n\t\tthis.#encryption = config.encryption ?? createDefaultEncryption();\n\t\tthis.#store = config.store ?? createSessionStorage();\n\t\tthis.#storageKeys = createStorageKeys(config.apiKey);\n\n\t\tlet storedState = null;\n\t\ttry {\n\t\t\tconst rawStoredValue = this.#store.get(this.#storageKeys.STATE);\n\t\t\tif (rawStoredValue) {\n\t\t\t\tstoredState = JSON.parse(rawStoredValue);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Ignore errors\n\t\t}\n\n\t\tthis.$zkLoginState = atom(storedState || {});\n\t\tthis.$zkLoginSession = atom({ initialized: false, value: null });\n\n\t\t// Hydrate the session on mount:\n\t\tonMount(this.$zkLoginSession, () => {\n\t\t\tthis.getSession();\n\t\t});\n\n\t\tonSet(this.$zkLoginState, ({ newValue }) => {\n\t\t\tthis.#store.set(this.#storageKeys.STATE, JSON.stringify(newValue));\n\t\t});\n\t}\n\n\tget enokiClient() {\n\t\treturn this.#enokiClient;\n\t}\n\n\tasync createAuthorizationURL(input: {\n\t\tprovider: AuthProvider;\n\t\tclientId: string;\n\t\tredirectUrl: string;\n\t\tnetwork?: 'mainnet' | 'testnet' | 'devnet';\n\t\textraParams?: Record<string, unknown>;\n\t}) {\n\t\tconst ephemeralKeyPair = this.#useNativeCryptoSigner\n\t\t\t? await WebCryptoSigner.generate()\n\t\t\t: new Ed25519Keypair();\n\n\t\tconst { nonce, randomness, maxEpoch, estimatedExpiration } =\n\t\t\tawait this.#enokiClient.createZkLoginNonce({\n\t\t\t\tnetwork: input.network,\n\t\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t\t});\n\n\t\tconst params = new URLSearchParams({\n\t\t\t...input.extraParams,\n\t\t\tnonce,\n\t\t\tclient_id: input.clientId,\n\t\t\tredirect_uri: input.redirectUrl,\n\t\t\tresponse_type: 'id_token',\n\t\t\t// TODO: Eventually fetch the scopes for this client ID from the Enoki service:\n\t\t\tscope: [\n\t\t\t\t'openid',\n\t\t\t\t// Merge the requested scopes in with the required openid scopes:\n\t\t\t\t...(input.extraParams && 'scope' in input.extraParams\n\t\t\t\t\t? (input.extraParams.scope as string[])\n\t\t\t\t\t: []),\n\t\t\t]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(' '),\n\t\t});\n\n\t\tlet oauthUrl: string;\n\t\tswitch (input.provider) {\n\t\t\tcase 'google': {\n\t\t\t\toauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'facebook': {\n\t\t\t\toauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'twitch': {\n\t\t\t\tparams.set('force_verify', 'true');\n\t\t\t\toauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid provider: ${input.provider}`);\n\t\t}\n\n\t\tthis.$zkLoginState.set({ provider: input.provider });\n\t\tif (this.#useNativeCryptoSigner) {\n\t\t\tawait set('ephemeralKeyPair', (ephemeralKeyPair as WebCryptoSigner).export(), this.#idbStore);\n\t\t}\n\n\t\tawait this.#setSession({\n\t\t\texpiresAt: estimatedExpiration,\n\t\t\tmaxEpoch,\n\t\t\trandomness,\n\t\t\tephemeralKeyPair: this.#useNativeCryptoSigner\n\t\t\t\t? '@@native'\n\t\t\t\t: toBase64(\n\t\t\t\t\t\tdecodeSuiPrivateKey((ephemeralKeyPair as Ed25519Keypair).getSecretKey()).secretKey,\n\t\t\t\t\t),\n\t\t});\n\n\t\treturn oauthUrl;\n\t}\n\n\t// TODO: Should our SDK manage this automatically in addition to exposing a method?\n\tasync handleAuthCallback(hash: string = window.location.hash) {\n\t\tconst params = new URLSearchParams(hash.startsWith('#') ? hash.slice(1) : hash);\n\n\t\t// Before we handle the auth redirect and get the state, we need to restore it:\n\t\tconst zkp = await this.getSession();\n\n\t\tif (!zkp || !zkp.ephemeralKeyPair || !zkp.maxEpoch || !zkp.randomness) {\n\t\t\tthrow new Error(\n\t\t\t\t'Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this.',\n\t\t\t);\n\t\t}\n\n\t\tconst jwt = params.get('id_token');\n\t\tif (!jwt) {\n\t\t\tthrow new Error('Missing ID Token');\n\t\t}\n\n\t\tdecodeJwt(jwt);\n\n\t\tconst { address, salt, publicKey } = await this.#enokiClient.getZkLogin({ jwt });\n\n\t\tthis.$zkLoginState.set({\n\t\t\t...this.$zkLoginState.get(),\n\t\t\tsalt,\n\t\t\taddress,\n\t\t\tpublicKey,\n\t\t});\n\t\tawait this.#setSession({\n\t\t\t...zkp,\n\t\t\tjwt,\n\t\t});\n\n\t\treturn params.get('state');\n\t}\n\n\tasync #setSession(newValue: ZkLoginSession | null) {\n\t\tif (newValue) {\n\t\t\tconst storedValue = await this.#encryption.encrypt(\n\t\t\t\tthis.#encryptionKey,\n\t\t\t\tJSON.stringify(newValue),\n\t\t\t);\n\n\t\t\tthis.#store.set(this.#storageKeys.SESSION, storedValue);\n\t\t} else {\n\t\t\tthis.#store.delete(this.#storageKeys.SESSION);\n\t\t}\n\n\t\tthis.$zkLoginSession.set({ initialized: true, value: newValue });\n\t}\n\n\tasync getSession() {\n\t\tif (this.$zkLoginSession.get().initialized) {\n\t\t\treturn this.$zkLoginSession.get().value;\n\t\t}\n\n\t\ttry {\n\t\t\tconst storedValue = this.#store.get(this.#storageKeys.SESSION);\n\t\t\tif (!storedValue) return null;\n\n\t\t\tconst state: ZkLoginSession = JSON.parse(\n\t\t\t\tawait this.#encryption.decrypt(this.#encryptionKey, storedValue),\n\t\t\t);\n\n\t\t\t// TODO: Rather than having expiration act as a logout, we should keep the state that still is relevant,\n\t\t\t// and just clear out the expired session, but keep the other zkLogin state.\n\t\t\tif (state?.expiresAt && Date.now() > state.expiresAt) {\n\t\t\t\tawait this.logout();\n\t\t\t} else {\n\t\t\t\tthis.$zkLoginSession.set({ initialized: true, value: state });\n\t\t\t}\n\t\t} catch {\n\t\t\tthis.$zkLoginSession.set({ initialized: true, value: null });\n\t\t}\n\n\t\treturn this.$zkLoginSession.get().value;\n\t}\n\n\tasync logout() {\n\t\tthis.$zkLoginState.set({});\n\t\tthis.#store.delete(this.#storageKeys.STATE);\n\n\t\tif (this.#useNativeCryptoSigner) {\n\t\t\tawait clear(this.#idbStore);\n\t\t}\n\t\tawait this.#setSession(null);\n\t}\n\n\t// TODO: Should this return the proof if it already exists?\n\tasync getProof({ network }: { network?: EnokiNetwork } = {}) {\n\t\tconst zkp = await this.getSession();\n\t\tconst { salt } = this.$zkLoginState.get();\n\n\t\tif (zkp?.proof) {\n\t\t\tif (zkp.expiresAt && Date.now() > zkp.expiresAt) {\n\t\t\t\tthrow new Error('Stored proof is expired.');\n\t\t\t}\n\n\t\t\treturn zkp.proof;\n\t\t}\n\n\t\tif (!salt || !zkp || !zkp.jwt) {\n\t\t\tthrow new Error('Missing required parameters for proof generation');\n\t\t}\n\n\t\tlet storedNativeSigner: ExportedWebCryptoKeypair | undefined = undefined;\n\t\tif (this.#useNativeCryptoSigner && zkp.ephemeralKeyPair === '@@native') {\n\t\t\tstoredNativeSigner = await get('ephemeralKeyPair', this.#idbStore);\n\t\t\tif (!storedNativeSigner) {\n\t\t\t\tthrow new Error('Native signer not found in store.');\n\t\t\t}\n\t\t}\n\n\t\tconst ephemeralKeyPair =\n\t\t\tzkp.ephemeralKeyPair === '@@native'\n\t\t\t\t? WebCryptoSigner.import(storedNativeSigner!)\n\t\t\t\t: Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));\n\n\t\tconst proof = await this.#enokiClient.createZkLoginZkp({\n\t\t\tnetwork,\n\t\t\tjwt: zkp.jwt,\n\t\t\tmaxEpoch: zkp.maxEpoch,\n\t\t\trandomness: zkp.randomness,\n\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t});\n\n\t\tawait this.#setSession({\n\t\t\t...zkp,\n\t\t\tproof,\n\t\t});\n\n\t\treturn proof;\n\t}\n\n\tasync getKeypair({ network }: { network?: EnokiNetwork } = {}) {\n\t\t// Get the proof, so that we ensure it exists in state:\n\t\tawait this.getProof({ network });\n\n\t\tconst zkp = await this.getSession();\n\n\t\t// Check to see if we have the essentials for a keypair:\n\t\tconst { address } = this.$zkLoginState.get();\n\t\tif (!address || !zkp || !zkp.proof) {\n\t\t\tthrow new Error('Missing required data for keypair generation.');\n\t\t}\n\n\t\tif (Date.now() > zkp.expiresAt) {\n\t\t\tthrow new Error('Stored proof is expired.');\n\t\t}\n\n\t\tlet storedNativeSigner: ExportedWebCryptoKeypair | undefined = undefined;\n\t\tif (this.#useNativeCryptoSigner && zkp.ephemeralKeyPair === '@@native') {\n\t\t\tstoredNativeSigner = await get('ephemeralKeyPair', this.#idbStore);\n\t\t\tif (!storedNativeSigner) {\n\t\t\t\tthrow new Error('Native signer not found in store.');\n\t\t\t}\n\t\t}\n\n\t\tconst ephemeralKeypair =\n\t\t\tzkp.ephemeralKeyPair === '@@native'\n\t\t\t\t? WebCryptoSigner.import(storedNativeSigner!)\n\t\t\t\t: Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));\n\n\t\treturn new EnokiKeypair({\n\t\t\taddress,\n\t\t\tephemeralKeypair,\n\t\t\tmaxEpoch: zkp.maxEpoch,\n\t\t\tproof: zkp.proof,\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
