{
  "version": 3,
  "sources": ["../../src/Sui.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type Transport from '@ledgerhq/hw-transport';\nimport sha256 from 'fast-sha256';\n\nexport type GetPublicKeyResult = {\n\tpublicKey: Uint8Array;\n\taddress: Uint8Array;\n};\n\nexport type SignTransactionResult = {\n\tsignature: Uint8Array;\n};\n\nexport type GetVersionResult = {\n\tmajor: number;\n\tminor: number;\n\tpatch: number;\n};\n\nenum LedgerToHost {\n\tRESULT_ACCUMULATING = 0,\n\tRESULT_FINAL = 1,\n\tGET_CHUNK = 2,\n\tPUT_CHUNK = 3,\n}\n\nenum HostToLedger {\n\tSTART = 0,\n\tGET_CHUNK_RESPONSE_SUCCESS = 1,\n\tGET_CHUNK_RESPONSE_FAILURE = 2,\n\tPUT_CHUNK_RESPONSE = 3,\n\tRESULT_ACCUMULATING_RESPONSE = 4,\n}\n\n/**\n * Sui API\n *\n * @example\n * import Sui from \"@mysten/ledgerjs-hw-app-sui\";\n * const sui = new Sui(transport)\n */\nexport default class Sui {\n\ttransport: Transport;\n\treadonly #verbose: boolean;\n\n\tconstructor(transport: Transport, scrambleKey = 'default_sui_scramble_key', verbose = false) {\n\t\tthis.#verbose = verbose;\n\t\tthis.transport = transport;\n\t\tthis.transport.decorateAppAPIMethods(\n\t\t\tthis,\n\t\t\t['getPublicKey', 'signTransaction', 'getVersion'],\n\t\t\tscrambleKey,\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves the public key associated with a particular BIP32 path from the Ledger app.\n\t *\n\t * @param path - the path to retrieve.\n\t * @param displayOnDevice - whether or not the address should be displayed on the device.\n\t *\n\t */\n\tasync getPublicKey(path: string, displayOnDevice = false): Promise<GetPublicKeyResult> {\n\t\tconst cla = 0x00;\n\t\tconst ins = displayOnDevice ? 0x01 : 0x02;\n\t\tconst p1 = 0;\n\t\tconst p2 = 0;\n\t\tconst payload = buildBip32KeyPayload(path);\n\t\tconst response = await this.#sendChunks(cla, ins, p1, p2, payload);\n\t\tconst keySize = response[0];\n\n\t\tconst publicKey = response.slice(1, keySize + 1); // slice uses end index.\n\t\tlet address: Uint8Array | null = null;\n\t\tif (response.length > keySize + 2) {\n\t\t\tconst addressSize = response[keySize + 1];\n\t\t\taddress = response.slice(keySize + 2, keySize + 2 + addressSize);\n\t\t}\n\t\tconst res: GetPublicKeyResult = {\n\t\t\tpublicKey: publicKey,\n\t\t\taddress: address!,\n\t\t};\n\t\treturn res;\n\t}\n\n\t/**\n\t * Sign a transaction with the key at a BIP32 path.\n\t *\n\t * @param txn - The transaction bytes to sign.\n\t * @param path - The path to use when signing the transaction.\n\t * @param options - Additional options used for clear signing purposes.\n\t */\n\tasync signTransaction(\n\t\tpath: string,\n\t\ttxn: Uint8Array,\n\t\toptions?: {\n\t\t\tbcsObjects: Uint8Array[];\n\t\t},\n\t): Promise<SignTransactionResult> {\n\t\tconst cla = 0x00;\n\t\tconst ins = 0x03;\n\t\tconst p1 = 0;\n\t\tconst p2 = 0;\n\n\t\tif (this.#verbose) this.#log(txn);\n\n\t\t// Transaction payload is the byte length as uint32le followed by the bytes\n\t\tconst rawTxn = Buffer.from(txn);\n\t\tconst hashSize = Buffer.alloc(4);\n\t\thashSize.writeUInt32LE(rawTxn.length, 0);\n\n\t\t// Build transaction payload:\n\t\tconst payloadTxn = Buffer.concat([hashSize, rawTxn]);\n\t\tthis.#log('Payload Txn', payloadTxn);\n\n\t\tconst bip32KeyPayload = buildBip32KeyPayload(path);\n\t\tconst payloads = [payloadTxn, bip32KeyPayload];\n\n\t\t// The public getVersion is decorated with a lock in the constructor:\n\t\tconst { major } = await this.#internalGetVersion();\n\t\tconst bcsObjects = options?.bcsObjects ?? [];\n\n\t\tthis.#log('Objects list length', bcsObjects.length);\n\t\tthis.#log('App version', major);\n\n\t\tif (major > 0 && bcsObjects.length > 0) {\n\t\t\t// Build object list payload:\n\t\t\tconst numItems = Buffer.alloc(4);\n\t\t\tnumItems.writeUInt32LE(bcsObjects.length, 0);\n\n\t\t\tlet listData = Buffer.from(numItems);\n\n\t\t\t// Add each item with its length prefix:\n\t\t\tfor (const item of bcsObjects) {\n\t\t\t\tconst rawItem = Buffer.from(item);\n\t\t\t\tconst itemLen = Buffer.alloc(4);\n\t\t\t\titemLen.writeUInt32LE(rawItem.length, 0);\n\n\t\t\t\tlistData = Buffer.concat([listData, itemLen, rawItem]);\n\t\t\t}\n\n\t\t\tpayloads.push(listData);\n\t\t}\n\n\t\t// Send the chunks and return the signature\n\t\tconst signature = await this.#sendChunks(cla, ins, p1, p2, payloads);\n\t\treturn { signature };\n\t}\n\n\t/**\n\t * Retrieve the app version on the attached Ledger device.\n\t */\n\tasync getVersion(): Promise<GetVersionResult> {\n\t\treturn await this.#internalGetVersion();\n\t}\n\n\tasync #internalGetVersion() {\n\t\tconst [major, minor, patch] = await this.#sendChunks(0x00, 0x00, 0x00, 0x00, Buffer.alloc(1));\n\t\treturn {\n\t\t\tmajor,\n\t\t\tminor,\n\t\t\tpatch,\n\t\t};\n\t}\n\n\t/**\n\t * Convert a raw payload into what is essentially a singly-linked list of chunks, which\n\t * allows the ledger to re-seek the data in a secure fashion.\n\t */\n\tasync #sendChunks(\n\t\tcla: number,\n\t\tins: number,\n\t\tp1: number,\n\t\tp2: number,\n\t\tpayload: Buffer | Buffer[],\n\t\t// Constant (protocol dependent) data that the ledger may want to refer to\n\t\t// besides the payload.\n\t\textraData: Map<String, Buffer> = new Map<String, Buffer>(),\n\t): Promise<Buffer> {\n\t\tconst chunkSize = 180;\n\t\tif (!(payload instanceof Array)) {\n\t\t\tpayload = [payload];\n\t\t}\n\t\tconst parameterList: Buffer[] = [];\n\t\tlet data = new Map<String, Buffer>(extraData);\n\t\tfor (let j = 0; j < payload.length; j++) {\n\t\t\tconst chunkList: Buffer[] = [];\n\t\t\tfor (let i = 0; i < payload[j].length; i += chunkSize) {\n\t\t\t\tconst cur = payload[j].slice(i, i + chunkSize);\n\t\t\t\tchunkList.push(cur);\n\t\t\t}\n\t\t\t// Store the hash that points to the \"rest of the list of chunks\"\n\t\t\tlet lastHash = Buffer.alloc(32);\n\t\t\tthis.#log(lastHash);\n\t\t\t// Since we are doing a foldr, we process the last chunk first\n\t\t\t// We have to do it this way, because a block knows the hash of\n\t\t\t// the next block.\n\t\t\tdata = chunkList.reduceRight((blocks, chunk) => {\n\t\t\t\tconst linkedChunk = Buffer.concat([lastHash, chunk]);\n\t\t\t\tthis.#log('Chunk: ', chunk);\n\t\t\t\tthis.#log('linkedChunk: ', linkedChunk);\n\t\t\t\tlastHash = Buffer.from(sha256(linkedChunk));\n\t\t\t\tblocks.set(lastHash.toString('hex'), linkedChunk);\n\t\t\t\treturn blocks;\n\t\t\t}, data);\n\t\t\tparameterList.push(lastHash);\n\t\t\tlastHash = Buffer.alloc(32);\n\t\t}\n\t\tthis.#log(data);\n\t\treturn await this.#handleBlocksProtocol(\n\t\t\tcla,\n\t\t\tins,\n\t\t\tp1,\n\t\t\tp2,\n\t\t\tBuffer.concat(([Buffer.from([HostToLedger.START])] as Buffer[]).concat(parameterList)),\n\t\t\tdata,\n\t\t);\n\t}\n\n\tasync #handleBlocksProtocol(\n\t\tcla: number,\n\t\tins: number,\n\t\tp1: number,\n\t\tp2: number,\n\t\tinitialPayload: Buffer,\n\t\tdata: Map<String, Buffer>,\n\t): Promise<Buffer> {\n\t\tlet payload = initialPayload;\n\t\tlet result = Buffer.alloc(0);\n\t\tdo {\n\t\t\tthis.#log('Sending payload to ledger: ', payload.toString('hex'));\n\t\t\tconst rv = await this.transport.send(cla, ins, p1, p2, payload);\n\t\t\tthis.#log('Received response: ', rv);\n\t\t\tvar rv_instruction = rv[0];\n\t\t\tconst rv_payload = rv.slice(1, rv.length - 2); // Last two bytes are a return code.\n\t\t\tif (!(rv_instruction in LedgerToHost)) {\n\t\t\t\tthrow new TypeError('Unknown instruction returned from ledger');\n\t\t\t}\n\t\t\tswitch (rv_instruction) {\n\t\t\t\tcase LedgerToHost.RESULT_ACCUMULATING:\n\t\t\t\tcase LedgerToHost.RESULT_FINAL:\n\t\t\t\t\tresult = Buffer.concat([result, rv_payload]);\n\t\t\t\t\t// Won't actually send this if we drop out of the loop for RESULT_FINAL\n\t\t\t\t\tpayload = Buffer.from([HostToLedger.RESULT_ACCUMULATING_RESPONSE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LedgerToHost.GET_CHUNK:\n\t\t\t\t\tconst chunk = data.get(rv_payload.toString('hex'));\n\t\t\t\t\tthis.#log('Getting block ', rv_payload);\n\t\t\t\t\tthis.#log('Found block ', chunk);\n\t\t\t\t\tif (chunk) {\n\t\t\t\t\t\tpayload = Buffer.concat([\n\t\t\t\t\t\t\tBuffer.from([HostToLedger.GET_CHUNK_RESPONSE_SUCCESS]),\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpayload = Buffer.from([HostToLedger.GET_CHUNK_RESPONSE_FAILURE]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LedgerToHost.PUT_CHUNK:\n\t\t\t\t\tdata.set(Buffer.from(sha256(rv_payload)).toString('hex'), rv_payload);\n\t\t\t\t\tpayload = Buffer.from([HostToLedger.PUT_CHUNK_RESPONSE]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (rv_instruction !== LedgerToHost.RESULT_FINAL);\n\t\treturn result;\n\t}\n\n\t#log(...args: any[]) {\n\t\tif (this.#verbose) console.log(args);\n\t}\n}\n\nfunction buildBip32KeyPayload(path: string): Buffer {\n\tconst paths = splitPath(path);\n\t// Bip32Key payload is:\n\t// 1 byte with number of elements in u32 array path\n\t// Followed by the u32 array itself\n\tconst payload = Buffer.alloc(1 + paths.length * 4);\n\tpayload[0] = paths.length;\n\tpaths.forEach((element, index) => {\n\t\tpayload.writeUInt32LE(element, 1 + 4 * index);\n\t});\n\treturn payload;\n}\n\n// TODO use bip32-path library\nfunction splitPath(path: string): number[] {\n\tconst result: number[] = [];\n\tconst components = path.split('/');\n\tcomponents.forEach((element) => {\n\t\tlet number = parseInt(element, 10);\n\n\t\tif (isNaN(number)) {\n\t\t\treturn; // FIXME shouldn't it throws instead?\n\t\t}\n\n\t\tif (element.length > 1 && element[element.length - 1] === \"'\") {\n\t\t\tnumber += 0x80000000;\n\t\t}\n\n\t\tresult.push(number);\n\t});\n\treturn result;\n}\n"],
  "mappings": "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",
  "names": ["LedgerToHost", "HostToLedger"]
}
