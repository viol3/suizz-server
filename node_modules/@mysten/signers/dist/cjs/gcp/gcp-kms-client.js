"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var gcp_kms_client_exports = {};
__export(gcp_kms_client_exports, {
  GcpKmsSigner: () => GcpKmsSigner
});
module.exports = __toCommonJS(gcp_kms_client_exports);
var import_kms = require("@google-cloud/kms");
var import_cryptography = require("@mysten/sui/cryptography");
var import_secp256k1 = require("@mysten/sui/keypairs/secp256k1");
var import_secp256r1 = require("@mysten/sui/keypairs/secp256r1");
var import_utils = require("@mysten/sui/utils");
var import_utils2 = require("../utils/utils.js");
var _publicKey, _client, _versionName;
const _GcpKmsSigner = class _GcpKmsSigner extends import_cryptography.Signer {
  /**
   * Creates an instance of GcpKmsSigner. It's expected to call the static `fromOptions`
   * or `fromVersionName` method to create an instance.
   * For example:
   * ```
   * const signer = await GcpKmsSigner.fromVersionName(versionName);
   * ```
   * @throws Will throw an error if required GCP credentials are not provided.
   */
  constructor({ versionName, client, publicKey }) {
    super();
    __privateAdd(this, _publicKey);
    /** GCP KMS client instance */
    __privateAdd(this, _client);
    /** GCP KMS version name (generated from `client.cryptoKeyVersionPath()`) */
    __privateAdd(this, _versionName);
    if (!versionName) throw new Error("Version name is required");
    __privateSet(this, _client, client);
    __privateSet(this, _versionName, versionName);
    __privateSet(this, _publicKey, publicKey);
  }
  /**
   * Retrieves the key scheme used by this signer.
   * @returns GCP supports only `Secp256k1` and `Secp256r1` schemes.
   */
  getKeyScheme() {
    return import_cryptography.SIGNATURE_FLAG_TO_SCHEME[__privateGet(this, _publicKey).flag()];
  }
  /**
   * Retrieves the public key associated with this signer.
   * @returns The Secp256k1PublicKey instance.
   * @throws Will throw an error if the public key has not been initialized.
   */
  getPublicKey() {
    return __privateGet(this, _publicKey);
  }
  /**
   * Signs the given data using GCP KMS.
   * @param bytes - The data to be signed as a Uint8Array.
   * @returns A promise that resolves to the signature as a Uint8Array.
   * @throws Will throw an error if the public key is not initialized or if signing fails.
   */
  async sign(bytes) {
    const [signResponse] = await __privateGet(this, _client).asymmetricSign({
      name: __privateGet(this, _versionName),
      data: bytes
    });
    if (!signResponse.signature) {
      throw new Error("No signature returned from GCP KMS");
    }
    return (0, import_utils2.getConcatenatedSignature)(signResponse.signature, this.getKeyScheme());
  }
  /**
   * Synchronous signing is not supported by GCP KMS.
   * @throws Always throws an error indicating synchronous signing is unsupported.
   */
  signData() {
    throw new Error("GCP Signer does not support sync signing");
  }
  /**
   * Creates a GCP KMS signer from the provided options.
   * Expects the credentials file to be set as an env variable
   * (GOOGLE_APPLICATION_CREDENTIALS).
   */
  static async fromOptions(options) {
    const client = new import_kms.KeyManagementServiceClient();
    const versionName = client.cryptoKeyVersionPath(
      options.projectId,
      options.location,
      options.keyRing,
      options.cryptoKey,
      options.cryptoKeyVersion
    );
    return new _GcpKmsSigner({
      versionName,
      client,
      publicKey: await getPublicKey(client, versionName)
    });
  }
  static async fromVersionName(versionName) {
    const client = new import_kms.KeyManagementServiceClient();
    return new _GcpKmsSigner({
      versionName,
      client,
      publicKey: await getPublicKey(client, versionName)
    });
  }
};
_publicKey = new WeakMap();
_client = new WeakMap();
_versionName = new WeakMap();
let GcpKmsSigner = _GcpKmsSigner;
async function getPublicKey(client, versionName) {
  const [publicKey] = await client.getPublicKey({ name: versionName });
  const { algorithm, pem } = publicKey;
  if (!pem) throw new Error("No PEM key returned from GCP KMS");
  const base64 = pem.replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "").replace(/\s/g, "");
  const compressedKey = (0, import_utils2.publicKeyFromDER)((0, import_utils.fromBase64)(base64));
  switch (algorithm) {
    case "EC_SIGN_SECP256K1_SHA256":
      return new import_secp256k1.Secp256k1PublicKey(compressedKey);
    case "EC_SIGN_P256_SHA256":
      return new import_secp256r1.Secp256r1PublicKey(compressedKey);
    default:
      throw new Error(`Unsupported algorithm: ${algorithm}`);
  }
}
//# sourceMappingURL=gcp-kms-client.js.map
