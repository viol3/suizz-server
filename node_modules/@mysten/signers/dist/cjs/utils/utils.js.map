{
  "version": 3,
  "sources": ["../../../src/utils/utils.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { secp256r1 } from '@noble/curves/p256';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { ASN1Construction, ASN1TagClass, DERElement } from 'asn1-ts';\n\n/** The total number of bits in the DER bit string for the uncompressed public key. */\nexport const DER_BIT_STRING_LENGTH = 520;\n\n/** The total number of bytes corresponding to the DER bit string length. */\nexport const DER_BYTES_LENGTH = DER_BIT_STRING_LENGTH / 8;\n\n// Reference Specifications:\n// https://datatracker.ietf.org/doc/html/rfc5480#section-2.2\n// https://www.secg.org/sec1-v2.pdf\n\n/**\n * Converts an array of bits into a byte array.\n *\n * @param bitsArray - A `Uint8ClampedArray` representing the bits to convert.\n * @returns A `Uint8Array` containing the corresponding bytes.\n *\n * @throws {Error} If the input array does not have the expected length.\n */\nfunction bitsToBytes(bitsArray: Uint8ClampedArray): Uint8Array {\n\tconst bytes = new Uint8Array(DER_BYTES_LENGTH);\n\tfor (let i = 0; i < DER_BIT_STRING_LENGTH; i++) {\n\t\tif (bitsArray[i] === 1) {\n\t\t\tbytes[Math.floor(i / 8)] |= 1 << (7 - (i % 8));\n\t\t}\n\t}\n\treturn bytes;\n}\n\nexport function publicKeyFromDER(derBytes: Uint8Array) {\n\tconst encodedData: Uint8Array = derBytes;\n\tconst derElement = new DERElement();\n\tderElement.fromBytes(encodedData);\n\n\t// Validate the ASN.1 structure of the public key\n\tif (\n\t\t!(\n\t\t\tderElement.tagClass === ASN1TagClass.universal &&\n\t\t\tderElement.construction === ASN1Construction.constructed\n\t\t)\n\t) {\n\t\tthrow new Error('Unexpected ASN.1 structure');\n\t}\n\n\tconst components = derElement.components;\n\tconst publicKeyElement = components[1];\n\n\tif (!publicKeyElement) {\n\t\tthrow new Error('Public Key not found in the DER structure');\n\t}\n\n\treturn compressPublicKeyClamped(publicKeyElement.bitString);\n}\n\nexport function getConcatenatedSignature(signature: Uint8Array, keyScheme: string) {\n\tif (!signature || signature.length === 0) {\n\t\tthrow new Error('Invalid signature');\n\t}\n\n\t// Initialize a DERElement to parse the DER-encoded signature\n\tconst derElement = new DERElement();\n\tderElement.fromBytes(signature);\n\n\tconst [r, s] = derElement.toJSON() as [string, string];\n\n\tswitch (keyScheme) {\n\t\tcase 'Secp256k1':\n\t\t\treturn new secp256k1.Signature(BigInt(r), BigInt(s))\n\t\t\t\t.normalizeS()\n\t\t\t\t.toCompactRawBytes() as Uint8Array<ArrayBuffer>;\n\t\tcase 'Secp256r1':\n\t\t\treturn new secp256r1.Signature(BigInt(r), BigInt(s))\n\t\t\t\t.normalizeS()\n\t\t\t\t.toCompactRawBytes() as Uint8Array<ArrayBuffer>;\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported key scheme');\n\t}\n}\n\n/**\n * Compresses an uncompressed public key into its compressed form.\n *\n * The uncompressed key must follow the DER bit string format as specified in [RFC 5480](https://datatracker.ietf.org/doc/html/rfc5480#section-2.2)\n * and [SEC 1: Elliptic Curve Cryptography](https://www.secg.org/sec1-v2.pdf).\n *\n * @param uncompressedKey - A `Uint8ClampedArray` representing the uncompressed public key bits.\n * @returns A `Uint8Array` containing the compressed public key.\n *\n * @throws {Error} If the uncompressed key has an unexpected length or does not start with the expected prefix.\n */\nexport function compressPublicKeyClamped(uncompressedKey: Uint8ClampedArray): Uint8Array {\n\tif (uncompressedKey.length !== DER_BIT_STRING_LENGTH) {\n\t\tthrow new Error('Unexpected length for an uncompressed public key');\n\t}\n\n\t// Convert bits to bytes\n\tconst uncompressedBytes = bitsToBytes(uncompressedKey);\n\n\t// Ensure the public key starts with the standard uncompressed prefix 0x04\n\tif (uncompressedBytes[0] !== 0x04) {\n\t\tthrow new Error('Public key does not start with 0x04');\n\t}\n\n\t// Extract X-Coordinate (skip the first byte, which is the prefix 0x04)\n\tconst xCoord = uncompressedBytes.slice(1, 33);\n\n\t// Determine parity byte for Y coordinate based on the last byte\n\tconst yCoordLastByte = uncompressedBytes[64];\n\tconst parityByte = yCoordLastByte % 2 === 0 ? 0x02 : 0x03;\n\n\t// Return the compressed public key consisting of the parity byte and X-coordinate\n\treturn new Uint8Array([parityByte, ...xCoord]);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,kBAA0B;AAC1B,uBAA0B;AAC1B,qBAA2D;AAGpD,MAAM,wBAAwB;AAG9B,MAAM,mBAAmB,wBAAwB;AAcxD,SAAS,YAAY,WAA0C;AAC9D,QAAM,QAAQ,IAAI,WAAW,gBAAgB;AAC7C,WAAS,IAAI,GAAG,IAAI,uBAAuB,KAAK;AAC/C,QAAI,UAAU,CAAC,MAAM,GAAG;AACvB,YAAM,KAAK,MAAM,IAAI,CAAC,CAAC,KAAK,KAAM,IAAK,IAAI;AAAA,IAC5C;AAAA,EACD;AACA,SAAO;AACR;AAEO,SAAS,iBAAiB,UAAsB;AACtD,QAAM,cAA0B;AAChC,QAAM,aAAa,IAAI,0BAAW;AAClC,aAAW,UAAU,WAAW;AAGhC,MACC,EACC,WAAW,aAAa,4BAAa,aACrC,WAAW,iBAAiB,gCAAiB,cAE7C;AACD,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC7C;AAEA,QAAM,aAAa,WAAW;AAC9B,QAAM,mBAAmB,WAAW,CAAC;AAErC,MAAI,CAAC,kBAAkB;AACtB,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC5D;AAEA,SAAO,yBAAyB,iBAAiB,SAAS;AAC3D;AAEO,SAAS,yBAAyB,WAAuB,WAAmB;AAClF,MAAI,CAAC,aAAa,UAAU,WAAW,GAAG;AACzC,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACpC;AAGA,QAAM,aAAa,IAAI,0BAAW;AAClC,aAAW,UAAU,SAAS;AAE9B,QAAM,CAAC,GAAG,CAAC,IAAI,WAAW,OAAO;AAEjC,UAAQ,WAAW;AAAA,IAClB,KAAK;AACJ,aAAO,IAAI,2BAAU,UAAU,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,EACjD,WAAW,EACX,kBAAkB;AAAA,IACrB,KAAK;AACJ,aAAO,IAAI,sBAAU,UAAU,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,EACjD,WAAW,EACX,kBAAkB;AAAA,IACrB;AACC,YAAM,IAAI,MAAM,wBAAwB;AAAA,EAC1C;AACD;AAaO,SAAS,yBAAyB,iBAAgD;AACxF,MAAI,gBAAgB,WAAW,uBAAuB;AACrD,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACnE;AAGA,QAAM,oBAAoB,YAAY,eAAe;AAGrD,MAAI,kBAAkB,CAAC,MAAM,GAAM;AAClC,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACtD;AAGA,QAAM,SAAS,kBAAkB,MAAM,GAAG,EAAE;AAG5C,QAAM,iBAAiB,kBAAkB,EAAE;AAC3C,QAAM,aAAa,iBAAiB,MAAM,IAAI,IAAO;AAGrD,SAAO,IAAI,WAAW,CAAC,YAAY,GAAG,MAAM,CAAC;AAC9C;",
  "names": []
}
