var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _publicKey, _client, _kmsKeyId;
import { SIGNATURE_FLAG_TO_SCHEME, Signer } from "@mysten/sui/cryptography";
import { fromBase64, toBase64 } from "@mysten/sui/utils";
import { getConcatenatedSignature } from "../utils/utils.js";
import { AwsKmsClient } from "./aws-client.js";
const _AwsKmsSigner = class _AwsKmsSigner extends Signer {
  /**
   * Creates an instance of AwsKmsSigner. It's expected to call the static `fromKeyId` method to create an instance.
   * For example:
   * ```
   * const signer = await AwsKmsSigner.fromKeyId(keyId, options);
   * ```
   * @throws Will throw an error if required AWS credentials or region are not provided.
   */
  constructor({ kmsKeyId, client, publicKey }) {
    super();
    __privateAdd(this, _publicKey);
    /** AWS KMS client instance */
    __privateAdd(this, _client);
    /** AWS KMS Key ID used for signing */
    __privateAdd(this, _kmsKeyId);
    if (!kmsKeyId) throw new Error("KMS Key ID is required");
    __privateSet(this, _client, client);
    __privateSet(this, _kmsKeyId, kmsKeyId);
    __privateSet(this, _publicKey, publicKey);
  }
  /**
   * Retrieves the key scheme used by this signer.
   * @returns AWS supports only Secp256k1 and Secp256r1 schemes.
   */
  getKeyScheme() {
    return SIGNATURE_FLAG_TO_SCHEME[__privateGet(this, _publicKey).flag()];
  }
  /**
   * Retrieves the public key associated with this signer.
   * @returns The Secp256k1PublicKey instance.
   * @throws Will throw an error if the public key has not been initialized.
   */
  getPublicKey() {
    return __privateGet(this, _publicKey);
  }
  /**
   * Signs the given data using AWS KMS.
   * @param bytes - The data to be signed as a Uint8Array.
   * @returns A promise that resolves to the signature as a Uint8Array.
   * @throws Will throw an error if the public key is not initialized or if signing fails.
   */
  async sign(bytes) {
    const signResponse = await __privateGet(this, _client).runCommand("Sign", {
      KeyId: __privateGet(this, _kmsKeyId),
      Message: toBase64(bytes),
      MessageType: "RAW",
      SigningAlgorithm: "ECDSA_SHA_256"
    });
    return getConcatenatedSignature(fromBase64(signResponse.Signature), this.getKeyScheme());
  }
  /**
   * Synchronous signing is not supported by AWS KMS.
   * @throws Always throws an error indicating synchronous signing is unsupported.
   */
  signData() {
    throw new Error("KMS Signer does not support sync signing");
  }
  /**
   * Prepares the signer by fetching and setting the public key from AWS KMS.
   * It is recommended to initialize an `AwsKmsSigner` instance using this function.
   * @returns A promise that resolves once a `AwsKmsSigner` instance is prepared (public key is set).
   */
  static async fromKeyId(keyId, options) {
    const client = new AwsKmsClient(options);
    const pubKey = await client.getPublicKey(keyId);
    return new _AwsKmsSigner({
      kmsKeyId: keyId,
      client,
      publicKey: pubKey
    });
  }
};
_publicKey = new WeakMap();
_client = new WeakMap();
_kmsKeyId = new WeakMap();
let AwsKmsSigner = _AwsKmsSigner;
export {
  AwsKmsSigner
};
//# sourceMappingURL=aws-kms-signer.js.map
