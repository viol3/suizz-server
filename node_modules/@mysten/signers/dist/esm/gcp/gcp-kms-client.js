var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _publicKey, _client, _versionName;
import { KeyManagementServiceClient } from "@google-cloud/kms";
import { SIGNATURE_FLAG_TO_SCHEME, Signer } from "@mysten/sui/cryptography";
import { Secp256k1PublicKey } from "@mysten/sui/keypairs/secp256k1";
import { Secp256r1PublicKey } from "@mysten/sui/keypairs/secp256r1";
import { fromBase64 } from "@mysten/sui/utils";
import { getConcatenatedSignature, publicKeyFromDER } from "../utils/utils.js";
const _GcpKmsSigner = class _GcpKmsSigner extends Signer {
  /**
   * Creates an instance of GcpKmsSigner. It's expected to call the static `fromOptions`
   * or `fromVersionName` method to create an instance.
   * For example:
   * ```
   * const signer = await GcpKmsSigner.fromVersionName(versionName);
   * ```
   * @throws Will throw an error if required GCP credentials are not provided.
   */
  constructor({ versionName, client, publicKey }) {
    super();
    __privateAdd(this, _publicKey);
    /** GCP KMS client instance */
    __privateAdd(this, _client);
    /** GCP KMS version name (generated from `client.cryptoKeyVersionPath()`) */
    __privateAdd(this, _versionName);
    if (!versionName) throw new Error("Version name is required");
    __privateSet(this, _client, client);
    __privateSet(this, _versionName, versionName);
    __privateSet(this, _publicKey, publicKey);
  }
  /**
   * Retrieves the key scheme used by this signer.
   * @returns GCP supports only `Secp256k1` and `Secp256r1` schemes.
   */
  getKeyScheme() {
    return SIGNATURE_FLAG_TO_SCHEME[__privateGet(this, _publicKey).flag()];
  }
  /**
   * Retrieves the public key associated with this signer.
   * @returns The Secp256k1PublicKey instance.
   * @throws Will throw an error if the public key has not been initialized.
   */
  getPublicKey() {
    return __privateGet(this, _publicKey);
  }
  /**
   * Signs the given data using GCP KMS.
   * @param bytes - The data to be signed as a Uint8Array.
   * @returns A promise that resolves to the signature as a Uint8Array.
   * @throws Will throw an error if the public key is not initialized or if signing fails.
   */
  async sign(bytes) {
    const [signResponse] = await __privateGet(this, _client).asymmetricSign({
      name: __privateGet(this, _versionName),
      data: bytes
    });
    if (!signResponse.signature) {
      throw new Error("No signature returned from GCP KMS");
    }
    return getConcatenatedSignature(signResponse.signature, this.getKeyScheme());
  }
  /**
   * Synchronous signing is not supported by GCP KMS.
   * @throws Always throws an error indicating synchronous signing is unsupported.
   */
  signData() {
    throw new Error("GCP Signer does not support sync signing");
  }
  /**
   * Creates a GCP KMS signer from the provided options.
   * Expects the credentials file to be set as an env variable
   * (GOOGLE_APPLICATION_CREDENTIALS).
   */
  static async fromOptions(options) {
    const client = new KeyManagementServiceClient();
    const versionName = client.cryptoKeyVersionPath(
      options.projectId,
      options.location,
      options.keyRing,
      options.cryptoKey,
      options.cryptoKeyVersion
    );
    return new _GcpKmsSigner({
      versionName,
      client,
      publicKey: await getPublicKey(client, versionName)
    });
  }
  static async fromVersionName(versionName) {
    const client = new KeyManagementServiceClient();
    return new _GcpKmsSigner({
      versionName,
      client,
      publicKey: await getPublicKey(client, versionName)
    });
  }
};
_publicKey = new WeakMap();
_client = new WeakMap();
_versionName = new WeakMap();
let GcpKmsSigner = _GcpKmsSigner;
async function getPublicKey(client, versionName) {
  const [publicKey] = await client.getPublicKey({ name: versionName });
  const { algorithm, pem } = publicKey;
  if (!pem) throw new Error("No PEM key returned from GCP KMS");
  const base64 = pem.replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "").replace(/\s/g, "");
  const compressedKey = publicKeyFromDER(fromBase64(base64));
  switch (algorithm) {
    case "EC_SIGN_SECP256K1_SHA256":
      return new Secp256k1PublicKey(compressedKey);
    case "EC_SIGN_P256_SHA256":
      return new Secp256r1PublicKey(compressedKey);
    default:
      throw new Error(`Unsupported algorithm: ${algorithm}`);
  }
}
export {
  GcpKmsSigner
};
//# sourceMappingURL=gcp-kms-client.js.map
